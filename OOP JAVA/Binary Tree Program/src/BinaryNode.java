import java.util.Arrays;import java.util.LinkedList;import java.util.Queue;/** * A class that represents nodes in a binary tree. *  * @author Frank M. Carrano * @version 2.0 */class BinaryNode<T> implements BinaryNodeInterface<T>, java.io.Serializable{  private static final long serialVersionUID = 6828929352995534482L; // needed for serializable objects    private T data;  private BinaryNode<T> left;  private BinaryNode<T> right;    public BinaryNode()  {    this(null); // call next constructor  } // end default constructor    public BinaryNode(T dataPortion)  {    this(dataPortion, null, null); // call next constructor  } // end constructor  public BinaryNode(T dataPortion, BinaryNode<T> leftChild,                                   BinaryNode<T> rightChild)  {    data = dataPortion;    left = leftChild;    right = rightChild;  } // end constructor    public T getData()  {    return data;  } // end getData    public void setData(T newData)  {    data = newData;  } // end setData    public BinaryNodeInterface<T> getLeftChild()  {    return left;  } // end getLeftChild  	public BinaryNodeInterface<T> getRightChild()	{		return right;	} // end getRightChild    public void setLeftChild(BinaryNodeInterface<T> leftChild)    {      left = (BinaryNode<T>)leftChild;    } // end setLeftChild  	public void setRightChild(BinaryNodeInterface<T> rightChild)	{		right = (BinaryNode<T>)rightChild;	} // end setRightChild		    public boolean hasLeftChild()    {      return left != null;    } // end hasLeftChild  	public boolean hasRightChild()	{		return right != null;	} // end hasRightChild	    public boolean isLeaf()    {      return (left == null) && (right == null);    } // end isLeaf    	// 26.06	public BinaryNodeInterface<T> copy()	{	  BinaryNode<T> newRoot = new BinaryNode<T>(data);	  	  if (left != null)	    newRoot.left = (BinaryNode<T>)left.copy();	    	  if (right != null)	    newRoot.right = (BinaryNode<T>)right.copy();	    	  return newRoot;		} // end copy	// 26.11	public int getHeight()	{	  return getHeight(this); // call private getHeight	} // end getHeight	// 26.11	private int getHeight(BinaryNode<T> node)	{	  int height = 0;	  	  if (node != null)	    height = 1 + Math.max(getHeight(node.left), getHeight(node.right));	                          	  return height;	} // end getHeight	// 26.11	public int getNumberOfNodes()	{	  int leftNumber = 0;	  int rightNumber = 0;	  	  if (left != null)	    leftNumber = left.getNumberOfNodes();	    	  if (right != null)	    rightNumber = right.getNumberOfNodes();	    	  return 1 + leftNumber + rightNumber;	} // end getNumberOfNodes	//serialize method used to store my tree	String serialize(BinaryNodeInterface<String> rootNode) {		if (rootNode == null) { //if the node is null just return X in the file			return "X:";		}		//then recursively call the function to serialize every thing on the left and every node on the right		String leftSerialized = serialize(rootNode.getLeftChild());		String rightSerialized = serialize(rootNode.getRightChild());		//then return the data seperated by a colon, this is so I can delimit the file.		return rootNode.getData() + ":" + leftSerialized + rightSerialized;	}	public BinaryNode deserialize(String s){  	//create a Queue of our nodes and store them individually by using the split method.		Queue<String> nodesLeft = new LinkedList<>(Arrays.asList(s.split(":")));// then call our helper method that does the majority of the work		return deserializeHelper(nodesLeft);	}	public BinaryNode deserializeHelper(Queue<String> nodesLeft) {		 //poll the value of the node in the current queue , i.e get the value and remove it			String valueOfNode = nodesLeft.poll();			//if its X then just return null as the node			if (valueOfNode.equals("X")) return null;			BinaryNode newNode = new BinaryNode(valueOfNode);//create new node that stores value of current node in the queue		//then recursively call the function to set the left and right nodes that are stored in the file			newNode.left = deserializeHelper(nodesLeft);			newNode.right = deserializeHelper(nodesLeft);			//return the node			return newNode;	}} // end BinaryNode